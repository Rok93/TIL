# 도메인 주도 설계 이해

> 경우에 따라 DDD 기술 규칙과 패턴이 DDD 구현에 방해가 될 수 있다. 
> 중요한 것은 패턴 자체가 아니라 비즈니스 문제에 맞게 코드를 구성하고 동일한 `비즈니스 용어(유비쿼터스 언어)`를 사용하는 것이다.

# 레거시 코드

## Anemic Domain Model
빈약한 도메인 모델
객체지향에서 말하는 오브젝트는 상태(state)와 행위(behavior)로 구성되어 있어야 한다.
자바엔터프라이즈 개발에서 흔히 사용되는 방식은 단지 상태 값, 즉 데이터만 가지는 데이터홀더 개념의 단순 오브젝트
대부분의 서버사이드 아키텍처라고 제시되는 구조가 빈약한 도메인모델의 사용을 부추기고 있다는 점이 문제였다.
대부분의 자바 엔터프라이즈 아키텍처가 가지고 있는 이런 구조적인 한계들은 **결국 과도한 서비스 레이어의 사용**(= fat service)을 부추긴다.

## Business Object
* 비즈니스가 분산되어 구현된 오브젝트
* 동작을 실행하거나 관리하는 클래스
* 클라이언트 데이터에 대한 요청을 DAO에 호출하는 역할도 한다.
* 모든 기능을 해당 소프트웨어 개체로 분리한다.

## Big Service Layer
* 이런 형태의 거대한 서비스 레이어(big service layer) 형태는 객체지향의 설계원칙에 맞지 않을 뿐더러 도메인로직을 여러 곳에 산재하게 만들 뿐더러 코드의 중복과 오브젝트의 재활용성을 극히 떨어뜨리게 한다.
* 초기 스프링의 예제나 스프링 개발자들에 의해서 쓰여진 스프링 서적의 샘플 코드도 이런 구조를 그대로 사용했다는 것은 이런 모델이 얼마나 자연스럽게 개발자들에게 받아들여지고 사용되어져왔는지 짐작하게 해준다.


# 유연한 설계 - ASSERTION

## 계약에 의한 설계
* Design by Contract
* 사전 조건은 계약에 명시된 단서 조항
* 사후 조건은 연산의 부수 효과를 의미하며 호출되는 연산에서 보장하는 결과를 기술한다.
* 클래스 불변식은 임의의 연산이 종료된 후 만족해야 하는 객체의 상태에 관한 단언을 기술한다.
* 계약에 의한 설계를 지킨다면 클라이언트의 입장에서는 내가 의도한 결과대로 나올 것임을 확신할 수 있다.
* API를 만드는 입장에서는 안전한 데이터만 파라미터로 넘어올것이라는 확신할 수 있다.
* 그렇다면 이 계약 조건을 어떻게 드러낼 것인가?

## 단위 테스트
* 테스트 코드를 작성하는 이유 중에는 ‘테스트 코드를 통해 요구 사항을 이해할 수 있다‘와 ‘클라이언트가 객체를 사용하는 방법에 관한 적절한 코드 예제를 제공하는 것’
* 테스트 코드는 도메인에 관한 풍부한 정보를 포함하고 전달한다.
