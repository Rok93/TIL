# 읽은 글 
-[x] [웹 API 디자인](https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design) <br> 

### 데이터 필터링 및 페이지 매기기
단일 URI를 통해 리소스 컬렉션을 표시하면 정보의 하위 집합만 필요할 때에도 애플리케이션이 대량의 데이터를 가져올 수 있습니다. 예를 들어 클라이언트 애플리케이션에서 비용이 특정 값을 초과하는 모든 주문을 찾아야 한다고 가정해 봅시다. 클라이언트 응용 프로그램은 /orders URI에서 모든 주문을 검색한 후 클라이언트 쪽에서 이러한 주문을 필터링할 것입니다. 이 프로세스는 매우 비효율적입니다. Web API를 호스팅하는 서버의 네트워크 대역폭 및 처리 성능이 낭비됩니다.
이 방법 대신, /orders?minCost=n 처럼 API가 URI의 쿼리 문자열에서 필터 전달을 허용할 수 있습니다. 그러면 Web API가 쿼리 문자열의 minCost 매개 변수를 구문 분석 및 처리하고 서버 쪽에서 필터링된 결과를 반환합니다.
컬렉션 리소스에 대한 GET 요청은 다수의 항목을 반환할 가능성이 있습니다. 단일 요청에서 반환하는 데이터의 양이 제한되도록 Web API를 디자인해야 합니다. 검색할 최대 항목 수와 컬렉션의 시작 오프셋을 지정하는 쿼리 문자열을 지원하는 방안을 고려해 봅니다. 예를 들면 다음과 같습니다.

``/orders?limit=25&offset=50`` <br> 

또한 서비스 거부 공격을 방지하기 위해 반환되는 항목 수를 제한하는 방안도 고려해 봅니다. 클라이언트 애플리케이션을 돕기 위해, 페이지가 매겨진 데이터를 반환하는 GET 요청은 컬렉션의 사용할 수 있는 총 리소스 수를 나타내는 모종의 메타데이터 형식을 포함해야 합니다.
필드 이름을 /orders?sort=ProductID 같은 값으로 가져오는 정렬 매개 변수를 제공하여 데이터를 가져올 때 데이터를 정렬하는 비슷한 전략을 사용할 수 있습니다. 그러나 쿼리 문자열 매개 변수는 여러 캐시 구현에서 캐시된 데이터의 키로 사용되는 리소스 식별자의 일부를 구성하기 때문에 이 접근 방식은 캐싱에 나쁜 영향을 미칠 수 있습니다.
각 항목에 대량의 데이터가 포함된 경우 각 항목에 대해 반환되는 필드를 제한하도록 이 접근 방식을 확장할 수 있습니다. 예를 들어 쉼표로 구분된 필드 목록을 수락하는 /orders?fields=ProductID,Quantity 같은 쿼리 문자열 매개 변수를 사용할 수 있습니다.
쿼리 문자열의 모든 선택적 매개 변수에 의미 있는 기본값을 제공합니다. 예를 들어 페이지 매김을 구현하는 경우 limit 매개 변수를 10으로, offset 매개 변수를 0으로 설정하고, 주문을 구현하는 경우 정렬 매개 변수를 리소스의 키로 설정하고, 프로젝션을 지원하는 경우 fields 매개 변수를 리소스의 모든 필드로 설정합니다.

### HATEOAS
**H**ypertext **A**s **T**he **E**ngine **O**f **A**pplication **S**tate 
리소스의 상태에 따라 반환되는 링크 집합이 달라질 수 있다. 이것이 바로 "애플리케이션 상태 엔진"이라는 하이퍼텍스트가 의미하는 바이다.

## RESTful 웹 API 버전 관리 
버전관리가 없는 경우는 본문 글을 참조하자 

* URI 버전 관리
웹 API를 수정하거나 리소스의 체계를 변경할 때마다 각 리소스의 URI에 버전 번호를 추가합니다. 앞에서는 기존 URI가 전과 같이 계속 작동하여 원래 체계를 준수하는 리소스를 반환해야 합니다.

문제점: 이 체계는 모든 링크가 자신의 URI에 버전 번호를 포함해야 하므로 HATEOAS 구현을 복잡하게 만듭니다.

ex) ``https://adventure-works.com/v2/customers/3``  <br> 


* 쿼리 문자열 버전 관리
여러 URI를 제공하는 대신, HTTP 요청에 추가된 쿼리 문자열 내에 ``https://adventure-works.com/customers/3?version=2`` 같은 매개 변수를 사용하여 리소스의 버전을 지정할 수 있습니다. 
버전 매개 변수는 이전 클라이언트 애플리케이션에서 생략했다면 기본적으로 1과 같은 의미 있는 값입니다. 

문제점: 이 접근 방식은 같은 리소스가 언제나 같은 URI에서 검색된다는 의미 체계 장점이 있지만, 쿼리 문자열을 구문 분석하고 해당 HTTP 응답을 다시 보내기 위해 요청을 처리하는 코드에 따라 달라집니다. 
또한 이 접근 방식은 HATEOAS를 URI 버전 관리 메커니즘으로 구현할 때와 같이 복잡합니다.


* 헤더 버전 관리
버전 번호를 쿼리 문자열 매개 변수로 추가하지 않고 리소스의 버전을 나타내는 사용자 지정 헤더를 구현할 수 있습니다. 이 접근 방식을 사용하려면 클라이언트 애플리케이션이 적절한 헤더를 요청에 추가해야 
하지만, version 헤더가 생략된 경우 클라이언트 요청을 처리하는 코드가 기본값(버전 1)을 사용할 수 있습니다.

문제점: 앞의 두 방법과 마찬가지로 HATEOAS를 구현 하려면 모든 링크에 적절 한 사용자 지정 헤더를 포함 해야 합니다. 

* 미디어 형식 버전 관리
이 지침의 앞부분에서 설명한 대로, 클라이언트 애플리케이션은 웹 서버에 HTTP GET 요청을 보낼 때 Accept 헤더를 사용하여 처리할 수 있는 콘텐츠의 형식을 지정해야 합니다. 
흔히 Accept 헤더의 목적은 클라이언트 애플리케이션에서 응답 본문이 XML, JSON 또는 클라이언트가 구문 분석할 수 있는 몇몇 다른 일반적인 형식 중 어느 형식인지 지정할 수 있도록 하는 것입니다.
그러나 클라이언트 애플리케이션이 예상하는 리소스의 버전을 나타낼 수 있도록 하는 정보를 포함한 사용자 지정 미디어 형식을 정의할 수 있습니다. 
다음 예제는 Accept 헤더를 값 application/vnd.adventure-works.v1+json 과 함께 지정하는 요청을 나타냅니다. 
vnd.adventure-works.v1 요소는 웹 서버에 대해 리소스의 버전 1을 반환해야 한다는 것을 나타내며, 한편 json 요소는 응답 본문의 형식이 JSON이어야 함을 지정합니다.

요청을 처리하는 코드는 Accept 헤더를 처리하고 가능하면 해당 헤더를 적용해야 합니다. 클라이언트 애플리케이션은 Accept 헤더에 복수의 형식을 지정할 수 있으며, 이 경우 웹 서버는 응답 본문에 가장 적절한 형식을 선택할 수 있습니다. 
웹 서버는 Content-Type 헤더를 사용하여 응답 본문에 있는 데이터의 형식을 확인합니다.

문제점: Accept 헤더가 모든 알려진 미디어 형식을 지정하지 않은 경우, 웹 서버는 HTTP 406(승인 금지) 응답 메시지를 생성하거나 기본 미디어 형식이 포함된 메시지를 반환할 수 있습니다. 
이 접근 방식은 엄격히 말해서 버전 관리 메커니즘인지 여부에 대한 논란의 여지가 있으며 당연히 리소스 링크에 관련 데이터의 MIME 형식을 포함할 수 있는 HATEOAS에 적합합니다.

-[x] [MIME-Type, Content-Type이란?](https://juyoung-1008.tistory.com/4) <br> 

MIME는 이메일과 함께 동봉할 파일을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되었기 때문에 이름에 Internet Mail Extension 입니다 그렇지만 현재는 웹을 통해서 여러형태의 파일 전달하는데 쓰이고 있다.


-[x] [Javascript 기초 - 비동기 통신](https://samslow.github.io/development/2020/06/13/Javascript_Basic_Asyncronous/) **Async-Await** 사용법 궁금해서 찾아 봄!! 
  * 가급적이면 ES5에서는 Promise ES8부터는 Async-Await를 지원하니 이 둘을 적극적으로 사용하자. (기존의 나는 XMLHttpRequest 사용했음!, 이를 다루는 것은 매우 번거롭다)
-[x] [디자인 패턴 - 당신은 MVC를 안다고 할 수 있는가](https://samslow.github.io/development/2020/06/16/Design_pattern-MVC/) <br> 


### 내일 이어서 읽기 
-[ ] [스프링 RestTemplate](https://advenoh.tistory.com/46) <br> 
-[ ] [REST의 representational이란 무엇인가?](https://blog.npcode.com/2017/04/03/rest의-representation이란-무엇인가/) <br> 
  * represent가 '대표하다' 라는 의미로 알고있어서 REST를 풀어쓸 때마다 그 의미가 갑자기 헷갈리는 경우가 있었다. 여기서는 표현하다! 라는 의미로 생각하면 된다. REST는 Representational State Transfer 
  즉, 즉, 자원(resource)의 표현(representation) 에 의한 상태 전달 [참고](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)
  

## 영단어 

* idempotent : 멱등의(연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다) [네이버 사전](https://en.dict.naver.com/#/search?range=all&query=idempotent)


