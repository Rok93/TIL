# 고급 언어와 저급 언어

컴퓨터는 C, C++, Java, Python과 같은 프로그래밍 언어를 이해할 수 있을까요?
답은 "그렇지 않다"이다. 

프로그래밍 언어는 컴퓨터가 이해하는 언어가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어이다. 
컴퓨터는 이 언어를 이해하지 못한다. 이렇게 '사람을 위한 언어'를 **고급 언어**(high-level language)라고 한다.

반대로 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 **저급 언어**(low-level language)라고 한다.
그래서 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 한다. 

저급 언어는 `기계어`, `어셈블리어` 이렇게 두 가지 종류가 있다. 

우선 **기계어**(machine code)란 0과 1의 명령어 비트로 이루어진 언어이다. 다시 말해 기계어는 0과 1로 이루어진 명령어 모음이다. 

기계어는 오로지 컴퓨터만을 위해 만들어진 언어이기 때문에 사람이 읽으면 그 의미를 이해하기 어렵다. 
그래서 등장한 저급 언어가 `어셈블리어`(assembly language)이다.

어떤 개발자가 되길 희망하는지에 따라 저급 언어의 중요성이 달라진다. 
물론, 어셈블리어를 작성하거나 관찰할 일이 거의 없는 개발자도 있다. 
하지만 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보 보안 분야 등의 개발자는 아래와 같이 어셈블리어를 많이 이용한다. 

그리고 이러한 분야의 개발자들에게 어셈블리어란 '작성의 대상'일 뿐만 아니라 매우 중요한 '관찰의 대상'이기도 한다. 
어셈블리어를 읽으며 컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 즉 프로그램이 어떤 절차로 작동하는지를 가장 근본적인 단계에서부터 하나하나 추적하고 관리할 수 있기 때문이다. 

이처럼 저급 언어의 중요성이 달라질 수 있다. 
물론 개발 분야를 막론하고 앞서 설명한 고급 언어와 저급 언어의 차이를 이해하는 것은 매우 좋은 교양이기에 저급 언어 알아두는 것이 좋다. 

# 컴파일 언어와 인터프리터 언어
고급 언어는 어떻게 저급언어로 변환될까? 
크게 두 가지 방식이 있다.

첫 번째는 컴파일 방식, 두 번째 방식은 인터프리트 방식이 있다. 

컴파일 방식으로 작동하는 프로그래밍 언어를 **컴파일 언어**(compiled language), 인터프리트 방식으로 작동하는 프로그래밍 언어를 **인터프리터 언어**(interpreted language)라고 한다.

## 컴파일 언어


컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행하는 고급 언어이다. 
대표적인 컴파일언어는 C가 있다. 컴파일 언어로 작성된 소스 코드는 코드 전체가 저급 언어로 변환되는 과정을 거친다. 이 과정을 **컴파일**(compile)이라고 한다. 
그리고 컴파일을 수행해 주는 도구를 **컴파일러**(compiler)라고 한다. 

컴파일러는 개발자가 작성한 소스 코드 전체를 쭉 훑어보며 소스 코드에 문법적인 오류는 없는지, 실행 가능한 코드인지, 실행하는 데 불필요한 코드는 없는지 등을 따지며 
소스 코드를 처음부터 끝까지 저급 언어로 컴파일한다. 이때, 컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패한다. 

컴파일이 성공적으로 수행되면 개발자가 작성한 소스 코드는 컴퓨터가 이해할 수 있는 저급 언어로 변환된다. 
이렇게 컴파일러를 통해 저급 언어로 변환된 코드를 **목적 코드**(object code)라고 한다.

## 인터프리터 언어 

**인터프리터 언어**는 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어이다. 
대표적인 인터프리터 언어로 Python이 있다. 

소스 코드 전체가 저급 언어로 변환되는 컴파일 언어와는 달리, 인터프리터 언어는 소스 코드를 한줄씩 한 줄씩 차례가 실행한다. 
그리고 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구를 **인터프리터**(interpreter)라고 한다.
인터프리터 언어는 컴퓨터와 대화하듯 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다. 

그리고 소스 코드 내에 오류가 하나라도 있으면 컴파일이 불가능했던 컴파일 언어와는 달리, 인터프리터 언어는 오류가 있더라도 해당줄 직전까지는 올바르게 수행된다.
하지만 인터프리터 언어는 소스 코드를 한 줄씩 실행하기 때문에 컴파일 언어보다 실행 속도가 느리다는 단점이 있다.

# 목적 파일 VS 실행 파일 

이미지로 이루어진 파일을 이미지 파일이라 부르고, 텍스트로 이루어진 파일을 텍스트 파일이라고 부르듯이 목적 코드로 이루어진 파일을 **목적 파일**이라고 부른다. 
마찬가지로 실행 코드로 이루어진 파일을 실행 파일이라고 부른다. (ex. 윈도우의 .exe 확장자를 가진 파일)

목적 파일과 실행 파일은 같은 의미는 아니다. 
목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 한다. 

링킹은 목적 파일을 실행 파일로 만드는 과정이다.


# 명령어의 구조 

## 연산 코드와 오퍼랜드
* 명령어: 연산 코드와 오퍼랜드로 구성되어 있다. 
* 연산 코드(= 연산자): '명령어가 수행할 연산'
* 오퍼랜드(= 피연산자): '연산에 필요한 데이터' 또는 '연산에 필요한 데이터가 저장된 위치'

연산 코드가 담기는 영역을 **연산 코드 필드**라고 부르고, 색칠되지 않은 부분, 즉 오퍼랜드가 담기는 영역을 **오퍼랜드 필드**라고 한다. 


## 오퍼랜드

오퍼랜드는 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다.
다만 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다. 
그래서 오퍼랜드 필드를 **주소 필드**라고 부르기도 한다. 

오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러개가 있을 수도 있다. 

여기서 오퍼랜드가 하나도 없는 명령어를 `0-주소 명령어`라고 하고, 오퍼랜드가 하나인 명령어를 `1-주소 명령어`, 두 개인 명령어를 `2-주소 명령어`, 세 개인 명령어를 `3-주소 명령어`라고 한다. 

## 연산 코드

연산 코드 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다. 
1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

## 주소 지정 방식

왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 걸까?
이는 명령어 길이 때문이다.
오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.

